// GENERATED CODE - DO NOT MODIFY BY HAND
// coverage:ignore-file
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'event.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;
/// @nodoc
mixin _$Msg implements DiagnosticableTreeMixin {




@override
void debugFillProperties(DiagnosticPropertiesBuilder properties) {
  properties
    ..add(DiagnosticsProperty('type', 'Msg'))
    ;
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is Msg);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString({ DiagnosticLevel minLevel = DiagnosticLevel.info }) {
  return 'Msg()';
}


}

/// @nodoc
class $MsgCopyWith<$Res>  {
$MsgCopyWith(Msg _, $Res Function(Msg) __);
}


/// Adds pattern-matching-related methods to [Msg].
extension MsgPatterns on Msg {
/// A variant of `map` that fallback to returning `orElse`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeMap<TResult extends Object?>({TResult Function( CheckLoginStatus value)?  checkLoginStatus,TResult Function( LoginSuccess value)?  loginSuccess,TResult Function( LoginFailure value)?  loginFailure,TResult Function( Logout value)?  logout,TResult Function( ChangePage value)?  changePage,TResult Function( LoadPosts value)?  loadPosts,TResult Function( TogglePostSelection value)?  togglePostSelection,TResult Function( EnterSelectionMode value)?  enterSelectionMode,TResult Function( ExitSelectionMode value)?  exitSelectionMode,TResult Function( SelectAllPosts value)?  selectAllPosts,TResult Function( DeleteSelectedPosts value)?  deleteSelectedPosts,TResult Function( ChangeSorting value)?  changeSorting,TResult Function( LoadWorkspace value)?  loadWorkspace,TResult Function( PostCreated value)?  postCreated,TResult Function( CreatePostTitleChanged value)?  createPostTitleChanged,required TResult orElse(),}){
final _that = this;
switch (_that) {
case CheckLoginStatus() when checkLoginStatus != null:
return checkLoginStatus(_that);case LoginSuccess() when loginSuccess != null:
return loginSuccess(_that);case LoginFailure() when loginFailure != null:
return loginFailure(_that);case Logout() when logout != null:
return logout(_that);case ChangePage() when changePage != null:
return changePage(_that);case LoadPosts() when loadPosts != null:
return loadPosts(_that);case TogglePostSelection() when togglePostSelection != null:
return togglePostSelection(_that);case EnterSelectionMode() when enterSelectionMode != null:
return enterSelectionMode(_that);case ExitSelectionMode() when exitSelectionMode != null:
return exitSelectionMode(_that);case SelectAllPosts() when selectAllPosts != null:
return selectAllPosts(_that);case DeleteSelectedPosts() when deleteSelectedPosts != null:
return deleteSelectedPosts(_that);case ChangeSorting() when changeSorting != null:
return changeSorting(_that);case LoadWorkspace() when loadWorkspace != null:
return loadWorkspace(_that);case PostCreated() when postCreated != null:
return postCreated(_that);case CreatePostTitleChanged() when createPostTitleChanged != null:
return createPostTitleChanged(_that);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// Callbacks receives the raw object, upcasted.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case final Subclass2 value:
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult map<TResult extends Object?>({required TResult Function( CheckLoginStatus value)  checkLoginStatus,required TResult Function( LoginSuccess value)  loginSuccess,required TResult Function( LoginFailure value)  loginFailure,required TResult Function( Logout value)  logout,required TResult Function( ChangePage value)  changePage,required TResult Function( LoadPosts value)  loadPosts,required TResult Function( TogglePostSelection value)  togglePostSelection,required TResult Function( EnterSelectionMode value)  enterSelectionMode,required TResult Function( ExitSelectionMode value)  exitSelectionMode,required TResult Function( SelectAllPosts value)  selectAllPosts,required TResult Function( DeleteSelectedPosts value)  deleteSelectedPosts,required TResult Function( ChangeSorting value)  changeSorting,required TResult Function( LoadWorkspace value)  loadWorkspace,required TResult Function( PostCreated value)  postCreated,required TResult Function( CreatePostTitleChanged value)  createPostTitleChanged,}){
final _that = this;
switch (_that) {
case CheckLoginStatus():
return checkLoginStatus(_that);case LoginSuccess():
return loginSuccess(_that);case LoginFailure():
return loginFailure(_that);case Logout():
return logout(_that);case ChangePage():
return changePage(_that);case LoadPosts():
return loadPosts(_that);case TogglePostSelection():
return togglePostSelection(_that);case EnterSelectionMode():
return enterSelectionMode(_that);case ExitSelectionMode():
return exitSelectionMode(_that);case SelectAllPosts():
return selectAllPosts(_that);case DeleteSelectedPosts():
return deleteSelectedPosts(_that);case ChangeSorting():
return changeSorting(_that);case LoadWorkspace():
return loadWorkspace(_that);case PostCreated():
return postCreated(_that);case CreatePostTitleChanged():
return createPostTitleChanged(_that);}
}
/// A variant of `map` that fallback to returning `null`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>({TResult? Function( CheckLoginStatus value)?  checkLoginStatus,TResult? Function( LoginSuccess value)?  loginSuccess,TResult? Function( LoginFailure value)?  loginFailure,TResult? Function( Logout value)?  logout,TResult? Function( ChangePage value)?  changePage,TResult? Function( LoadPosts value)?  loadPosts,TResult? Function( TogglePostSelection value)?  togglePostSelection,TResult? Function( EnterSelectionMode value)?  enterSelectionMode,TResult? Function( ExitSelectionMode value)?  exitSelectionMode,TResult? Function( SelectAllPosts value)?  selectAllPosts,TResult? Function( DeleteSelectedPosts value)?  deleteSelectedPosts,TResult? Function( ChangeSorting value)?  changeSorting,TResult? Function( LoadWorkspace value)?  loadWorkspace,TResult? Function( PostCreated value)?  postCreated,TResult? Function( CreatePostTitleChanged value)?  createPostTitleChanged,}){
final _that = this;
switch (_that) {
case CheckLoginStatus() when checkLoginStatus != null:
return checkLoginStatus(_that);case LoginSuccess() when loginSuccess != null:
return loginSuccess(_that);case LoginFailure() when loginFailure != null:
return loginFailure(_that);case Logout() when logout != null:
return logout(_that);case ChangePage() when changePage != null:
return changePage(_that);case LoadPosts() when loadPosts != null:
return loadPosts(_that);case TogglePostSelection() when togglePostSelection != null:
return togglePostSelection(_that);case EnterSelectionMode() when enterSelectionMode != null:
return enterSelectionMode(_that);case ExitSelectionMode() when exitSelectionMode != null:
return exitSelectionMode(_that);case SelectAllPosts() when selectAllPosts != null:
return selectAllPosts(_that);case DeleteSelectedPosts() when deleteSelectedPosts != null:
return deleteSelectedPosts(_that);case ChangeSorting() when changeSorting != null:
return changeSorting(_that);case LoadWorkspace() when loadWorkspace != null:
return loadWorkspace(_that);case PostCreated() when postCreated != null:
return postCreated(_that);case CreatePostTitleChanged() when createPostTitleChanged != null:
return createPostTitleChanged(_that);case _:
  return null;

}
}
/// A variant of `when` that fallback to an `orElse` callback.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeWhen<TResult extends Object?>({TResult Function()?  checkLoginStatus,TResult Function( LoggedUser user,  bool online)?  loginSuccess,TResult Function()?  loginFailure,TResult Function()?  logout,TResult Function( PageId page)?  changePage,TResult Function( List<PostDesc> posts)?  loadPosts,TResult Function( int index)?  togglePostSelection,TResult Function( int initialIndex)?  enterSelectionMode,TResult Function()?  exitSelectionMode,TResult Function()?  selectAllPosts,TResult Function()?  deleteSelectedPosts,TResult Function( PostSorting sorting)?  changeSorting,TResult Function( LoggedUser user)?  loadWorkspace,TResult Function()?  postCreated,TResult Function( String title)?  createPostTitleChanged,required TResult orElse(),}) {final _that = this;
switch (_that) {
case CheckLoginStatus() when checkLoginStatus != null:
return checkLoginStatus();case LoginSuccess() when loginSuccess != null:
return loginSuccess(_that.user,_that.online);case LoginFailure() when loginFailure != null:
return loginFailure();case Logout() when logout != null:
return logout();case ChangePage() when changePage != null:
return changePage(_that.page);case LoadPosts() when loadPosts != null:
return loadPosts(_that.posts);case TogglePostSelection() when togglePostSelection != null:
return togglePostSelection(_that.index);case EnterSelectionMode() when enterSelectionMode != null:
return enterSelectionMode(_that.initialIndex);case ExitSelectionMode() when exitSelectionMode != null:
return exitSelectionMode();case SelectAllPosts() when selectAllPosts != null:
return selectAllPosts();case DeleteSelectedPosts() when deleteSelectedPosts != null:
return deleteSelectedPosts();case ChangeSorting() when changeSorting != null:
return changeSorting(_that.sorting);case LoadWorkspace() when loadWorkspace != null:
return loadWorkspace(_that.user);case PostCreated() when postCreated != null:
return postCreated();case CreatePostTitleChanged() when createPostTitleChanged != null:
return createPostTitleChanged(_that.title);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// As opposed to `map`, this offers destructuring.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case Subclass2(:final field2):
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult when<TResult extends Object?>({required TResult Function()  checkLoginStatus,required TResult Function( LoggedUser user,  bool online)  loginSuccess,required TResult Function()  loginFailure,required TResult Function()  logout,required TResult Function( PageId page)  changePage,required TResult Function( List<PostDesc> posts)  loadPosts,required TResult Function( int index)  togglePostSelection,required TResult Function( int initialIndex)  enterSelectionMode,required TResult Function()  exitSelectionMode,required TResult Function()  selectAllPosts,required TResult Function()  deleteSelectedPosts,required TResult Function( PostSorting sorting)  changeSorting,required TResult Function( LoggedUser user)  loadWorkspace,required TResult Function()  postCreated,required TResult Function( String title)  createPostTitleChanged,}) {final _that = this;
switch (_that) {
case CheckLoginStatus():
return checkLoginStatus();case LoginSuccess():
return loginSuccess(_that.user,_that.online);case LoginFailure():
return loginFailure();case Logout():
return logout();case ChangePage():
return changePage(_that.page);case LoadPosts():
return loadPosts(_that.posts);case TogglePostSelection():
return togglePostSelection(_that.index);case EnterSelectionMode():
return enterSelectionMode(_that.initialIndex);case ExitSelectionMode():
return exitSelectionMode();case SelectAllPosts():
return selectAllPosts();case DeleteSelectedPosts():
return deleteSelectedPosts();case ChangeSorting():
return changeSorting(_that.sorting);case LoadWorkspace():
return loadWorkspace(_that.user);case PostCreated():
return postCreated();case CreatePostTitleChanged():
return createPostTitleChanged(_that.title);}
}
/// A variant of `when` that fallback to returning `null`
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>({TResult? Function()?  checkLoginStatus,TResult? Function( LoggedUser user,  bool online)?  loginSuccess,TResult? Function()?  loginFailure,TResult? Function()?  logout,TResult? Function( PageId page)?  changePage,TResult? Function( List<PostDesc> posts)?  loadPosts,TResult? Function( int index)?  togglePostSelection,TResult? Function( int initialIndex)?  enterSelectionMode,TResult? Function()?  exitSelectionMode,TResult? Function()?  selectAllPosts,TResult? Function()?  deleteSelectedPosts,TResult? Function( PostSorting sorting)?  changeSorting,TResult? Function( LoggedUser user)?  loadWorkspace,TResult? Function()?  postCreated,TResult? Function( String title)?  createPostTitleChanged,}) {final _that = this;
switch (_that) {
case CheckLoginStatus() when checkLoginStatus != null:
return checkLoginStatus();case LoginSuccess() when loginSuccess != null:
return loginSuccess(_that.user,_that.online);case LoginFailure() when loginFailure != null:
return loginFailure();case Logout() when logout != null:
return logout();case ChangePage() when changePage != null:
return changePage(_that.page);case LoadPosts() when loadPosts != null:
return loadPosts(_that.posts);case TogglePostSelection() when togglePostSelection != null:
return togglePostSelection(_that.index);case EnterSelectionMode() when enterSelectionMode != null:
return enterSelectionMode(_that.initialIndex);case ExitSelectionMode() when exitSelectionMode != null:
return exitSelectionMode();case SelectAllPosts() when selectAllPosts != null:
return selectAllPosts();case DeleteSelectedPosts() when deleteSelectedPosts != null:
return deleteSelectedPosts();case ChangeSorting() when changeSorting != null:
return changeSorting(_that.sorting);case LoadWorkspace() when loadWorkspace != null:
return loadWorkspace(_that.user);case PostCreated() when postCreated != null:
return postCreated();case CreatePostTitleChanged() when createPostTitleChanged != null:
return createPostTitleChanged(_that.title);case _:
  return null;

}
}

}

/// @nodoc


class CheckLoginStatus with DiagnosticableTreeMixin implements Msg {
  const CheckLoginStatus();
  





@override
void debugFillProperties(DiagnosticPropertiesBuilder properties) {
  properties
    ..add(DiagnosticsProperty('type', 'Msg.checkLoginStatus'))
    ;
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CheckLoginStatus);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString({ DiagnosticLevel minLevel = DiagnosticLevel.info }) {
  return 'Msg.checkLoginStatus()';
}


}




/// @nodoc


class LoginSuccess with DiagnosticableTreeMixin implements Msg {
  const LoginSuccess(this.user, this.online);
  

 final  LoggedUser user;
 final  bool online;

/// Create a copy of Msg
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$LoginSuccessCopyWith<LoginSuccess> get copyWith => _$LoginSuccessCopyWithImpl<LoginSuccess>(this, _$identity);


@override
void debugFillProperties(DiagnosticPropertiesBuilder properties) {
  properties
    ..add(DiagnosticsProperty('type', 'Msg.loginSuccess'))
    ..add(DiagnosticsProperty('user', user))..add(DiagnosticsProperty('online', online));
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LoginSuccess&&(identical(other.user, user) || other.user == user)&&(identical(other.online, online) || other.online == online));
}


@override
int get hashCode => Object.hash(runtimeType,user,online);

@override
String toString({ DiagnosticLevel minLevel = DiagnosticLevel.info }) {
  return 'Msg.loginSuccess(user: $user, online: $online)';
}


}

/// @nodoc
abstract mixin class $LoginSuccessCopyWith<$Res> implements $MsgCopyWith<$Res> {
  factory $LoginSuccessCopyWith(LoginSuccess value, $Res Function(LoginSuccess) _then) = _$LoginSuccessCopyWithImpl;
@useResult
$Res call({
 LoggedUser user, bool online
});




}
/// @nodoc
class _$LoginSuccessCopyWithImpl<$Res>
    implements $LoginSuccessCopyWith<$Res> {
  _$LoginSuccessCopyWithImpl(this._self, this._then);

  final LoginSuccess _self;
  final $Res Function(LoginSuccess) _then;

/// Create a copy of Msg
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? user = null,Object? online = null,}) {
  return _then(LoginSuccess(
null == user ? _self.user : user // ignore: cast_nullable_to_non_nullable
as LoggedUser,null == online ? _self.online : online // ignore: cast_nullable_to_non_nullable
as bool,
  ));
}


}

/// @nodoc


class LoginFailure with DiagnosticableTreeMixin implements Msg {
  const LoginFailure();
  





@override
void debugFillProperties(DiagnosticPropertiesBuilder properties) {
  properties
    ..add(DiagnosticsProperty('type', 'Msg.loginFailure'))
    ;
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LoginFailure);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString({ DiagnosticLevel minLevel = DiagnosticLevel.info }) {
  return 'Msg.loginFailure()';
}


}




/// @nodoc


class Logout with DiagnosticableTreeMixin implements Msg {
  const Logout();
  





@override
void debugFillProperties(DiagnosticPropertiesBuilder properties) {
  properties
    ..add(DiagnosticsProperty('type', 'Msg.logout'))
    ;
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is Logout);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString({ DiagnosticLevel minLevel = DiagnosticLevel.info }) {
  return 'Msg.logout()';
}


}




/// @nodoc


class ChangePage with DiagnosticableTreeMixin implements Msg {
  const ChangePage(this.page);
  

 final  PageId page;

/// Create a copy of Msg
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ChangePageCopyWith<ChangePage> get copyWith => _$ChangePageCopyWithImpl<ChangePage>(this, _$identity);


@override
void debugFillProperties(DiagnosticPropertiesBuilder properties) {
  properties
    ..add(DiagnosticsProperty('type', 'Msg.changePage'))
    ..add(DiagnosticsProperty('page', page));
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ChangePage&&(identical(other.page, page) || other.page == page));
}


@override
int get hashCode => Object.hash(runtimeType,page);

@override
String toString({ DiagnosticLevel minLevel = DiagnosticLevel.info }) {
  return 'Msg.changePage(page: $page)';
}


}

/// @nodoc
abstract mixin class $ChangePageCopyWith<$Res> implements $MsgCopyWith<$Res> {
  factory $ChangePageCopyWith(ChangePage value, $Res Function(ChangePage) _then) = _$ChangePageCopyWithImpl;
@useResult
$Res call({
 PageId page
});




}
/// @nodoc
class _$ChangePageCopyWithImpl<$Res>
    implements $ChangePageCopyWith<$Res> {
  _$ChangePageCopyWithImpl(this._self, this._then);

  final ChangePage _self;
  final $Res Function(ChangePage) _then;

/// Create a copy of Msg
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? page = null,}) {
  return _then(ChangePage(
null == page ? _self.page : page // ignore: cast_nullable_to_non_nullable
as PageId,
  ));
}


}

/// @nodoc


class LoadPosts with DiagnosticableTreeMixin implements Msg {
  const LoadPosts(final  List<PostDesc> posts): _posts = posts;
  

 final  List<PostDesc> _posts;
 List<PostDesc> get posts {
  if (_posts is EqualUnmodifiableListView) return _posts;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_posts);
}


/// Create a copy of Msg
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$LoadPostsCopyWith<LoadPosts> get copyWith => _$LoadPostsCopyWithImpl<LoadPosts>(this, _$identity);


@override
void debugFillProperties(DiagnosticPropertiesBuilder properties) {
  properties
    ..add(DiagnosticsProperty('type', 'Msg.loadPosts'))
    ..add(DiagnosticsProperty('posts', posts));
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LoadPosts&&const DeepCollectionEquality().equals(other._posts, _posts));
}


@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_posts));

@override
String toString({ DiagnosticLevel minLevel = DiagnosticLevel.info }) {
  return 'Msg.loadPosts(posts: $posts)';
}


}

/// @nodoc
abstract mixin class $LoadPostsCopyWith<$Res> implements $MsgCopyWith<$Res> {
  factory $LoadPostsCopyWith(LoadPosts value, $Res Function(LoadPosts) _then) = _$LoadPostsCopyWithImpl;
@useResult
$Res call({
 List<PostDesc> posts
});




}
/// @nodoc
class _$LoadPostsCopyWithImpl<$Res>
    implements $LoadPostsCopyWith<$Res> {
  _$LoadPostsCopyWithImpl(this._self, this._then);

  final LoadPosts _self;
  final $Res Function(LoadPosts) _then;

/// Create a copy of Msg
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? posts = null,}) {
  return _then(LoadPosts(
null == posts ? _self._posts : posts // ignore: cast_nullable_to_non_nullable
as List<PostDesc>,
  ));
}


}

/// @nodoc


class TogglePostSelection with DiagnosticableTreeMixin implements Msg {
  const TogglePostSelection(this.index);
  

 final  int index;

/// Create a copy of Msg
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$TogglePostSelectionCopyWith<TogglePostSelection> get copyWith => _$TogglePostSelectionCopyWithImpl<TogglePostSelection>(this, _$identity);


@override
void debugFillProperties(DiagnosticPropertiesBuilder properties) {
  properties
    ..add(DiagnosticsProperty('type', 'Msg.togglePostSelection'))
    ..add(DiagnosticsProperty('index', index));
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is TogglePostSelection&&(identical(other.index, index) || other.index == index));
}


@override
int get hashCode => Object.hash(runtimeType,index);

@override
String toString({ DiagnosticLevel minLevel = DiagnosticLevel.info }) {
  return 'Msg.togglePostSelection(index: $index)';
}


}

/// @nodoc
abstract mixin class $TogglePostSelectionCopyWith<$Res> implements $MsgCopyWith<$Res> {
  factory $TogglePostSelectionCopyWith(TogglePostSelection value, $Res Function(TogglePostSelection) _then) = _$TogglePostSelectionCopyWithImpl;
@useResult
$Res call({
 int index
});




}
/// @nodoc
class _$TogglePostSelectionCopyWithImpl<$Res>
    implements $TogglePostSelectionCopyWith<$Res> {
  _$TogglePostSelectionCopyWithImpl(this._self, this._then);

  final TogglePostSelection _self;
  final $Res Function(TogglePostSelection) _then;

/// Create a copy of Msg
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? index = null,}) {
  return _then(TogglePostSelection(
null == index ? _self.index : index // ignore: cast_nullable_to_non_nullable
as int,
  ));
}


}

/// @nodoc


class EnterSelectionMode with DiagnosticableTreeMixin implements Msg {
  const EnterSelectionMode(this.initialIndex);
  

 final  int initialIndex;

/// Create a copy of Msg
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$EnterSelectionModeCopyWith<EnterSelectionMode> get copyWith => _$EnterSelectionModeCopyWithImpl<EnterSelectionMode>(this, _$identity);


@override
void debugFillProperties(DiagnosticPropertiesBuilder properties) {
  properties
    ..add(DiagnosticsProperty('type', 'Msg.enterSelectionMode'))
    ..add(DiagnosticsProperty('initialIndex', initialIndex));
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is EnterSelectionMode&&(identical(other.initialIndex, initialIndex) || other.initialIndex == initialIndex));
}


@override
int get hashCode => Object.hash(runtimeType,initialIndex);

@override
String toString({ DiagnosticLevel minLevel = DiagnosticLevel.info }) {
  return 'Msg.enterSelectionMode(initialIndex: $initialIndex)';
}


}

/// @nodoc
abstract mixin class $EnterSelectionModeCopyWith<$Res> implements $MsgCopyWith<$Res> {
  factory $EnterSelectionModeCopyWith(EnterSelectionMode value, $Res Function(EnterSelectionMode) _then) = _$EnterSelectionModeCopyWithImpl;
@useResult
$Res call({
 int initialIndex
});




}
/// @nodoc
class _$EnterSelectionModeCopyWithImpl<$Res>
    implements $EnterSelectionModeCopyWith<$Res> {
  _$EnterSelectionModeCopyWithImpl(this._self, this._then);

  final EnterSelectionMode _self;
  final $Res Function(EnterSelectionMode) _then;

/// Create a copy of Msg
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? initialIndex = null,}) {
  return _then(EnterSelectionMode(
null == initialIndex ? _self.initialIndex : initialIndex // ignore: cast_nullable_to_non_nullable
as int,
  ));
}


}

/// @nodoc


class ExitSelectionMode with DiagnosticableTreeMixin implements Msg {
  const ExitSelectionMode();
  





@override
void debugFillProperties(DiagnosticPropertiesBuilder properties) {
  properties
    ..add(DiagnosticsProperty('type', 'Msg.exitSelectionMode'))
    ;
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ExitSelectionMode);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString({ DiagnosticLevel minLevel = DiagnosticLevel.info }) {
  return 'Msg.exitSelectionMode()';
}


}




/// @nodoc


class SelectAllPosts with DiagnosticableTreeMixin implements Msg {
  const SelectAllPosts();
  





@override
void debugFillProperties(DiagnosticPropertiesBuilder properties) {
  properties
    ..add(DiagnosticsProperty('type', 'Msg.selectAllPosts'))
    ;
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SelectAllPosts);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString({ DiagnosticLevel minLevel = DiagnosticLevel.info }) {
  return 'Msg.selectAllPosts()';
}


}




/// @nodoc


class DeleteSelectedPosts with DiagnosticableTreeMixin implements Msg {
  const DeleteSelectedPosts();
  





@override
void debugFillProperties(DiagnosticPropertiesBuilder properties) {
  properties
    ..add(DiagnosticsProperty('type', 'Msg.deleteSelectedPosts'))
    ;
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DeleteSelectedPosts);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString({ DiagnosticLevel minLevel = DiagnosticLevel.info }) {
  return 'Msg.deleteSelectedPosts()';
}


}




/// @nodoc


class ChangeSorting with DiagnosticableTreeMixin implements Msg {
  const ChangeSorting(this.sorting);
  

 final  PostSorting sorting;

/// Create a copy of Msg
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ChangeSortingCopyWith<ChangeSorting> get copyWith => _$ChangeSortingCopyWithImpl<ChangeSorting>(this, _$identity);


@override
void debugFillProperties(DiagnosticPropertiesBuilder properties) {
  properties
    ..add(DiagnosticsProperty('type', 'Msg.changeSorting'))
    ..add(DiagnosticsProperty('sorting', sorting));
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ChangeSorting&&(identical(other.sorting, sorting) || other.sorting == sorting));
}


@override
int get hashCode => Object.hash(runtimeType,sorting);

@override
String toString({ DiagnosticLevel minLevel = DiagnosticLevel.info }) {
  return 'Msg.changeSorting(sorting: $sorting)';
}


}

/// @nodoc
abstract mixin class $ChangeSortingCopyWith<$Res> implements $MsgCopyWith<$Res> {
  factory $ChangeSortingCopyWith(ChangeSorting value, $Res Function(ChangeSorting) _then) = _$ChangeSortingCopyWithImpl;
@useResult
$Res call({
 PostSorting sorting
});




}
/// @nodoc
class _$ChangeSortingCopyWithImpl<$Res>
    implements $ChangeSortingCopyWith<$Res> {
  _$ChangeSortingCopyWithImpl(this._self, this._then);

  final ChangeSorting _self;
  final $Res Function(ChangeSorting) _then;

/// Create a copy of Msg
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? sorting = null,}) {
  return _then(ChangeSorting(
null == sorting ? _self.sorting : sorting // ignore: cast_nullable_to_non_nullable
as PostSorting,
  ));
}


}

/// @nodoc


class LoadWorkspace with DiagnosticableTreeMixin implements Msg {
  const LoadWorkspace(this.user);
  

 final  LoggedUser user;

/// Create a copy of Msg
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$LoadWorkspaceCopyWith<LoadWorkspace> get copyWith => _$LoadWorkspaceCopyWithImpl<LoadWorkspace>(this, _$identity);


@override
void debugFillProperties(DiagnosticPropertiesBuilder properties) {
  properties
    ..add(DiagnosticsProperty('type', 'Msg.loadWorkspace'))
    ..add(DiagnosticsProperty('user', user));
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LoadWorkspace&&(identical(other.user, user) || other.user == user));
}


@override
int get hashCode => Object.hash(runtimeType,user);

@override
String toString({ DiagnosticLevel minLevel = DiagnosticLevel.info }) {
  return 'Msg.loadWorkspace(user: $user)';
}


}

/// @nodoc
abstract mixin class $LoadWorkspaceCopyWith<$Res> implements $MsgCopyWith<$Res> {
  factory $LoadWorkspaceCopyWith(LoadWorkspace value, $Res Function(LoadWorkspace) _then) = _$LoadWorkspaceCopyWithImpl;
@useResult
$Res call({
 LoggedUser user
});




}
/// @nodoc
class _$LoadWorkspaceCopyWithImpl<$Res>
    implements $LoadWorkspaceCopyWith<$Res> {
  _$LoadWorkspaceCopyWithImpl(this._self, this._then);

  final LoadWorkspace _self;
  final $Res Function(LoadWorkspace) _then;

/// Create a copy of Msg
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? user = null,}) {
  return _then(LoadWorkspace(
null == user ? _self.user : user // ignore: cast_nullable_to_non_nullable
as LoggedUser,
  ));
}


}

/// @nodoc


class PostCreated with DiagnosticableTreeMixin implements Msg {
  const PostCreated();
  





@override
void debugFillProperties(DiagnosticPropertiesBuilder properties) {
  properties
    ..add(DiagnosticsProperty('type', 'Msg.postCreated'))
    ;
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is PostCreated);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString({ DiagnosticLevel minLevel = DiagnosticLevel.info }) {
  return 'Msg.postCreated()';
}


}




/// @nodoc


class CreatePostTitleChanged with DiagnosticableTreeMixin implements Msg {
  const CreatePostTitleChanged(this.title);
  

 final  String title;

/// Create a copy of Msg
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CreatePostTitleChangedCopyWith<CreatePostTitleChanged> get copyWith => _$CreatePostTitleChangedCopyWithImpl<CreatePostTitleChanged>(this, _$identity);


@override
void debugFillProperties(DiagnosticPropertiesBuilder properties) {
  properties
    ..add(DiagnosticsProperty('type', 'Msg.createPostTitleChanged'))
    ..add(DiagnosticsProperty('title', title));
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CreatePostTitleChanged&&(identical(other.title, title) || other.title == title));
}


@override
int get hashCode => Object.hash(runtimeType,title);

@override
String toString({ DiagnosticLevel minLevel = DiagnosticLevel.info }) {
  return 'Msg.createPostTitleChanged(title: $title)';
}


}

/// @nodoc
abstract mixin class $CreatePostTitleChangedCopyWith<$Res> implements $MsgCopyWith<$Res> {
  factory $CreatePostTitleChangedCopyWith(CreatePostTitleChanged value, $Res Function(CreatePostTitleChanged) _then) = _$CreatePostTitleChangedCopyWithImpl;
@useResult
$Res call({
 String title
});




}
/// @nodoc
class _$CreatePostTitleChangedCopyWithImpl<$Res>
    implements $CreatePostTitleChangedCopyWith<$Res> {
  _$CreatePostTitleChangedCopyWithImpl(this._self, this._then);

  final CreatePostTitleChanged _self;
  final $Res Function(CreatePostTitleChanged) _then;

/// Create a copy of Msg
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? title = null,}) {
  return _then(CreatePostTitleChanged(
null == title ? _self.title : title // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

// dart format on
